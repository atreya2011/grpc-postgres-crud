package main

import (
	"context"
	"flag"
	"log"
	"net"

	"github.com/go-pg/pg/orm"

	"github.com/go-pg/pg"
	"github.com/golang/protobuf/ptypes/empty"
	"github.com/atreya2011/grpc-practice/postgres-crud/postgrescrud"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
)

type service struct {
	DB *pg.DB
}

var grpcAddrFlag = flag.String("addr", ":7000", "Address host:port")

func main() {
	log.Printf("grpc server start on port %v", *grpcAddrFlag)
	// Step 1. listen for connections on tcp
	lis, err := net.Listen("tcp", *grpcAddrFlag)
	// Always handle errors
	if err != nil {
		log.Fatalf("frak")
	}
	// Step 2. Create a new grpc server instance
	srv := grpc.NewServer()
	// Step 3. Initialize the db and store it in service{}
	serv := initDB()
	// Step 4. Register the Service by passing the new server instance
	// and the server struct created above
	// The register function is present in pb.go
	postgrescrud.RegisterPostgresCrudServer(srv, serv)
	// Step 5. Serve the listener created above
	srv.Serve(lis)
}

// Create The following is the implementation of the Create service
// as defined in the proto file. It can be any implemention.
func (s *service) Create(ctx context.Context, req *postgrescrud.CreatePersonRequest) (*postgrescrud.CreatePersonResponse, error) {
	err := s.DB.Insert(req.Person)
	if err != nil {
		return nil, grpc.Errorf(codes.Internal, "Could not insert item into the database: %s", err)
	}
	return &postgrescrud.CreatePersonResponse{Id: 0}, nil
}

// Read The following is the implementation of the Read service
// as defined in the proto file. It can be any implemention.
func (s *service) Read(ctx context.Context, req *postgrescrud.ReadPersonRequest) (*postgrescrud.ReadPersonResponse, error) {
	// find person with id
	// initialize p with a point to person type
	p := new(postgrescrud.Person)
	// store the result in p using gorm.Where
	err := s.DB.Model(p).Where("id = ?", req.GetId()).First()
	if err != nil {
		log.Println(err)
	}
	// return response
	return &postgrescrud.ReadPersonResponse{Person: p}, nil
}

// List lists all the fullnames. Request is empty.
// Below is an example implementation
func (s *service) List(ctx context.Context, e *empty.Empty) (*postgrescrud.ListPeopleResponse, error) {
	// initialize slice of pointers to person
	var people []*postgrescrud.Person
	// pass this to gorm.Find() to fill it with results
	query := s.DB.Model(&people).Order("id ASC")
	err := query.Select()
	if err != nil {
		log.Println(err)
	}
	return &postgrescrud.ListPeopleResponse{Peoples: people}, nil
}

// Delete deletes record based on id
// below is an example implementation
// func (*service) Delete() {
// 	// Delete - delete product
// 	db.Delete(&product)
// }

func initDB() *service {
	// Connect to database
	db := pg.Connect(&pg.Options{
		User:     "atreya",
		Database: "atreya",
		Addr:     "localhost:5432",
	})
	// Drop table
	db.DropTable(&postgrescrud.Person{}, &orm.DropTableOptions{IfExists: true})
	// Create Table from person struct generated by gRPC
	db.CreateTable(&postgrescrud.Person{}, nil)

	// Create a new service instance and store the db
	s := &service{DB: db}

	// return the db
	return s
}
